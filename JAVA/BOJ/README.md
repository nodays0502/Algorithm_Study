15663번 N과M(9)
---
1. for문에 중복된 수가 들어가면 안되기에 일반적인 순열코드에서 list를 추가에 해당 for문에 들어간 숫자들을 저장한다.
2. 저장한 숫자들과 check배열을 통해 해당 값이 사용되었는지와 해당 수가 for문에서 사용하였는지를 체크해서 문제해결



15664번 N과M(10)
---
1. 입력값들을 오름차순으로 정렬한다.
2. 일반적인 조합코드의 for문의 인덱스를 배열의 다음값과 비교해 현재값과 다른값이 나올때까지 인덱스를 변경하여 


3085번 사탕게임
---
1. 어떻게 전체 다 체크할것인지 고민 -> 각 좌표에서 오른쪽과 밑으로 한번씩 스왑하고 모든 배열에서 사탕의 최대 갯수를 구한다.


2493번 탑
---
1. 인덱스와 해당하는 값을 스택으로 보관한다.
2. 인덱스를 줄여나가면서 스택에 있는 값과 비교하여 스택 값이 크다면 push를 해나간다.
3. 스택에 있는 값이 작다면 현재값보다 스택값이 나올때 까지 pop하거나 Empty일떄까지 pop한다.

2503번 숫자야구
---
1. 먼저 모든 값을 스트링으로 저장해서 입력값과 비교하려했다. -> 너무 많은 스트링 메모리 낭비 및 배열 메모리 낭비
2. 단순 순열을 통해 모든경우를 생성하고, 이 값을 check함수에 넣어 입력값과 비교 (StringBuffer를 사용하여, 조금이나마 메모리 절약)
3. 모든 입력값과 비교하여 하나라도 해당하지 않는다면 return을 통해 바로 빠져나오도록 


17952번 과제는 끝나지 않아!
---
1. 입력이 들어오면 시간을 줄여주고 0이면 결과값을 1 증가시켜주고, 아니면 스택에 넣는다.
2. 0이고 스택이 비어있지않으면 스택에서 값을 빼오고 시간을 줄이고 조건비교하고 맞지않으면 다시 스택에 넣는다.



10971번 외판원 순회2
---
1. 완전탐색을 통해 모든 길을 다 거쳤다.


7568번 덩치
---
1. 완전탐색으로 자신이 다른 사람보다 덩치가 크거나 비교할수 없다면 순위를 높혔다.(값을 낮추었다.)


1914번 하노이 탑
---
1. int ,long형으로 재귀를 통해 하노이 탑 구현한다 . 메모리 초과
2. 20 초과할시 BigInteger를 통해 해결한다. BigInteger은 문자로 저장하기 떄문에 거의 무한대로 저장가능하다.


3190번 뱀
---
1. deque을 이용하여 시간마다 뱀의 머리의 좌표를 앞으로 넣고 뒤쪽부분은 사과를 만나지 않으면 빼준다.
2. 인덱스를 넘어가거나 자신의 꼬리에 부딪히면 끝나도록 구현



17298번 오큰수
--- 
1. 위의 2493번 탑과 비슷한 문제라고 판단.  시간초과 및 틀림
2. 시간초과 -> StringBuilder를 통해 해결
3. 탑에서는 같은 크기가 존재하지 않았지만, 오큰수에서는 같은 크기가 존재하여 이를 처리하여 

13458본 시험
---
1. 틀린 이유를 int라고 착각 -> long으로 변경
2. 음수를 고려하지 않아서 오류 -> 음수일때 따로 처리해서 오류 

9935번 문자열 폭발
---
1. 문자열로 풀려고 하다가 메모리 초과와 시간 초과
2. 스택을 활용하여 입력값을 스택에 차례대로 넣으면서 스택이 폭발문자열보다 같거나 많아지면 위에서 부터 폭발문자열 길이 만큼 폭발문자열과 같은지 비교한다.
3. 문자열로 풀었을때 StringBuilder에서의 delete가 시간이 오래 걸려 시간초과가 나는 것으로  

16397번 탈출
---
1. depth가 가장 낮은 것을 찾아야 하는것이기 때문에 bfs를 사용. 
2. set을 통해 중복제거 . 부모가 같으면 자식들은 결과가 같기 때문에


9466번 텀 프로젝트＊
---
1. dfs에서 list를 매개변수로 사용하여 해당 방문한 노드를 체크한다. -> 시간초과
2. boolean타입 배열을 두개 활용하여 하나는 현재 방문중인것을 표시하고 다른 하나는 완료한 것을 표시하여 


14499번 주사위 돌리기 *
---
1. 주사위가 동서남북으로 이동했을때 전개도상에서 어떻게 움직이는지 확인 
2. 주사위의 전개도를 4x3배열로 표현한다.
3. 주사위가 북쪽으로 이동시 인덱스 1인 열을 2 1 5 6 을 한칸씩 위로 이동시켜 1 5 6 2 로 만든다. 남쪽일시 반대로 움직인다.
4. 주사위가 동쪽으로 이동시 인덱스 1인 행을 6 4 1 로 만든다. 그리고 3을 6이 있던 자리로 옮긴다. 서쪽일시 반대로 움직인다.

17406번 배열돌리기4 *
---
1. 순열 개념을 이용해 모든 경우의 수를 체크하고 각각의 depth마다 돌리기 전 배열을 저장한다.
2. while문을 통해 해당 아래 오른쪽 위 왼쪽순으로 인덱스를 벗어날 시 다음 순서를 탐색하도록 구현


5427번 불*
---
1. bfs를 이용하여 사람을 먼저 이동시키고 그 다음 불을 이동시킨다.
2. 불이 사람에 닿게되면 불 표시를 하지 않고 다른 표시를 한다. 
3. 해당 표시는 다음에 불표시로 바꾸고 q에 넣음으로써 무조건 불보다 사람이 먼저 이동하도록 구현


2206번 벽 부수고 이동하기
---
1. bfs를 통해 최단경로 탐색 . 3차원배열을 통해 해당 좌표에 처음방문했는데 판단하고 벽을 한번 뚫었는지 안뚫었는지 판단한다.

1525번 퍼즐
---
1. Node class를 만들어서 각각의 상황에 따른 배열과 얼마나 교환했는지 저장하고 bfs를 사용
2. 배열을 스트링으로 변환하고 set을 통해 중복을 제거한다.

1074번 Z
---
1. 분할정복 개념과 dfs를 이용하여 제일 작은 사각형이 될떄까지 dfs로 들어간다.
2. 몇사분면에 점이 존재하는지 체크하고 각 사분면에 따라 길이를 줄이고 결과값은 각 사분면에 들어갈떄 그 앞에 있는 배열의 개수를 더해주고 dfs에 들어간다.

15686번 치킨 배달
---
1. 입력 받을때 1(집)인 값과 2(치킨집)인 값을 list에 저장
2. 2의 값을 저장한 list에서 조합 방법을 통해 M개 선택하고 각각의 1의 값과 거리가 제일 짧은 2의 거리를 구해서 더해준다.
3. 가장 작은 값을 결과로 출력

2212번 센서 ＊
---
1. set을 통해 입력의 중복을 제거
2. set의 값을 list에 넣어서 오름차순 정렳한다.
3. 배열에 각 센서의 거리를 저장하고 정렬한다.
4. k==n일떄 3번에서 구한 배열에 n-1개 뺴고 더해서 값을 도출한다. 

8980번 택배 **
---
1. 시작순서대로 정렬 -> 틀림
2. 택배를 보내야하는 마을이 인접한 순서대로 정렬(길이가 짧은 순) -> 틀림
3. 도착하는 마을 순으로 오름차순 정렬 -> 통과
4. 그리디 적으로 봤을때 도착하는 순대로 마을을 보고 최대한 많은 택배를 챙긴다.
5. 도착순으로 봐야 뒤의 택배에 영향을 주지 않기 떄문이다.

1987번 알파벳
---
1. DP를 적용시키려다가 실패 (이전까지 어떤 알파벳을 사용했는지도 판단해야한다. 하려면 비트 마스크로 해야할 듯하다)
2. 백트래킹 개념을 사용해 4방탐색을 하며 들어갈때마다 해당하는 알파벳을 사용했는지 boolean타입으로 표시한다. 다시 뒤로오면 false로 표시한다.


14502번 연구소
---
1. 조합 개념을 이용하여 빈칸인 부분중 3부분을 1로 만드는 각각의 경우를 만들고 bfs를 통해 2가 얼마나 퍼질  있는지 확인
2. 처음에 0의 개수를 세고 이를 2가 퍼진만큼 뺴주고 각각의 경우는 0에서 1로 3개 만듦으로 3도 뺴준다.


2477번 참외밭*
---
1. 인접한 변의 곱은 다 더한 값이 3*(전체 넓이)에서 빠지는 넓이를 뺸 값이다.
2. 전체 넓이를 구하고 전체넓이 - 빠지는 넓이를 구한다.

14891번 톱니바퀴
---
1. deque를 이용하여 회전방향에 따라 앞의 것을 뒤에 넣거나 , 뒤의 것을 앞으로 넣는다.

15683번 감시 *
---
1. 재귀를 통해 각각의 경우에 따라 list<int[]>를 구성하여 list는 몇개의 경우가 있는지 알려주고, list의 요소는 그 경우에 해당하는 탐색 방향을 알려준다.
2. 되돌리기 코드를 잘못 구현하여 구현하는데 시간이 오래걸림. 겹치는 부분이 존재하는데 모두 같은 숫자로 넣어 되돌릴때 이전의 값까지 지워버렸다.
3. 행동의 순서에 따라 값을 다르게 줘서 위와 같은 경우가 안나오게 처리

15684번 사다리 조작 *
---
1. dfs 방식을 채택을 통해 모든 경우를 탐색하고 만약 방법을 찾았다면 찾는 것을 중단한다.
2. 다리 놓는것을 다 같은 숫자를 줘서 오류 발생
3. 몇번째에 놓여지는지에 따라 숫자를 매겨 위와 같은 오류 해결

2116번 주사위 쌓기
---
1. HashMap을 통해서 마주보고 있는 인덱스를 맵핑시켰다.
2. 재귀 방식을 통해 모든 경우를 확인한다. (매개변수로 현재 깊이와 주사위의 윗면을 주었다.)
3. boolean배열을 통해 사이드에 존재하는 수인지 체크한다. 
4. 사이드에 있다면 그중 값이 각 층마다 가장 큰 값을 찾아서 더해주고 이 값이 가장 큰 값을 찾는다. 
