1225번 암호생성기
---
1. 단순 queue를 이용하여 앞의 값을 poll하고 값을 빼주고 뒤에 push한다.
2. 이것보다는 8사이클을 돌면 모든 요소에서 -15가 되기 때문에 모든 요소가 15 초과이면 15를 뺴주고 , 제일 낮은 값이 15이하가 되게 만들었다.
3. queue를 이용해 1번의 방법보다 반복문을 덜 돌게 구현하였다.


1218번 괄호짝짓기(bracket)
---
1. 괄호의 시작인 것들을 스택에 넣어서 보관하고 괄호의 끝이 나왔을 떄, 스택에서 하나 pop해 비교한다.
2. 비교는 괄호의 시작을 모아놓은 String과 괄호의 끝을 모아놓은 String을 통해 비교하며, 인덱스가 같은 지를 비교한다. 
3. 마지막으로 스택이 비어있는지 확인하고 비어 있는지 확인한다.



2805번 달팽이 숫자
---
1. dfs를 통해 4방탐색을 오른쪽부터해서 막히면 아래 막히면 왼쪽 막히면 위쪽으로 가도록 구현한다.
2. 만약 칸이 채워져있다면, 막힌것으로 간주한다.

1493번 수의 새로운 연산
---
1. 먼저 각각의 대각선을 위에서 오른쪽 아래로 순차적으로 숫자를 적어나간다.
2. 1번 col의 y값은 n*(n+1)/2이므로 해당하는 값보다 같으면 1,n을 리턴하고, 해당값보다 커지면 n-1에 해당하는 대각선에서부터 값을 비교해나간다.
3. 각각의 y,x 좌표가 나온다면, 그 값들을 더해서 좌표에서 읽는다.

1863번 창용 마을 무리의 개수 * (크루스칼 알고리즘)
---
1. 크루스칼 알고리즘을 통해 무리를 나눈다. 무리를 나누기 전에 N개의 무리가 있다 생각하고 result를 N으로 초기화한다. 
2. 만약 무리가 통합된다면 result에서 하나씩 빼준다. 이때 union함수에서만 빼주면 된다. 
3. 2이상의 무리가 통합해도 1을 뺴주는 이유는 2이상의 무리가 형성될 때, 각각의 인원이 들어올떄마다 인원의 몫을 빼줬기 때문에 1만 빼주면 된다.  
